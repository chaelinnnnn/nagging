<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Î™ÖÏ†à ÏûîÏÜåÎ¶¨ Ïù∏ÌÑ∞ÎûôÌã∞Î∏å</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@500;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            background: #000;
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #fff;
            z-index: 1000;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div class="loading" id="loading">Î°úÎî© Ï§ë...</div>

<script>
    let audioElements = [];
    let currentIndex = 0;
    let words = [];
    let animationFrame;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // ÌëúÏãúÏö© Í∏∞Î≥∏ Î¨∏Íµ¨ (ÌïúÍµ≠Ïñ¥ Îã®Ïñ¥Îì§)
    const baseWords = [
        'Í≤∞ÌòºÏùÄ', 'Ïñ∏Ï†ú', 'Ìï†Í±∞Ïïº?', 'Ï∑®ÏóÖÏ§ÄÎπÑÎäî', 'ÏûòÎêòÍ≥†ÏûàÏñ¥?',
        'Ïï†Îäî', 'Ïñ∏Ï†ú', 'ÎÇ≥ÏùÑÍ±∞Ïïº?', 'ÏöîÏ¶ò', 'ÏõîÍ∏âÏùÄ',
        'ÏñºÎßàÎÇòÎ∞õÏïÑ?', 'Î∞òÏóêÏÑú', 'Î™áÎì±Ïù¥ÎÇòÌïòÎãà?'
    ];

    // Ïª¨Îü¨ ÌåîÎ†àÌä∏
    const colors = [
        '#FF6B9D', '#FFD32A', '#FFFA65', '#FFA502', '#FF6348',
        '#4CD137', '#00D2D3', '#55E6C1', '#00B894', '#1abc9c',
        '#54A0FF', '#5F27CD', '#A29BFE', '#FDA7DF', '#D980FA',
        '#ff6b81', '#ffa502', '#26de81', '#20bf6b', '#0fb9b1',
        '#45aaf2', '#4b7bec', '#a55eea', '#778ca3', '#4b6584',
        '#2d3436', '#636e72', '#574b90', '#8854d0', '#3c40c6',
        '#05c46b', '#0fbcf9', '#3c6382', '#596275', '#303952',
        '#833471', '#6c5ce7', '#00b894', '#fdcb6e', '#e17055',
        '#d63031', '#e84393', '#2d3436', '#636e72', '#b2bec3'
    ];

    // üî• ÏÉà ÏòÅÎ¨∏ ÌååÏùºÎ™Ö Î¶¨Ïä§Ìä∏ (ÏµúÏ¢Ö Î≤ÑÏ†Ñ)
    const audioFiles = [
        // Richard
        'richard-marriage.m4a', 'richard-when.m4a', 'richard-will.m4a',
        'richard-job.m4a', 'richard-going.m4a', 'richard-baby.m4a',
        'richard-have.m4a', 'richard-lately.m4a', 'richard-salary.m4a',
        'richard-howmuch.m4a', 'richard-class.m4a', 'richard-rank.m4a',

        // Bella
        'bella-marriage.m4a', 'bella-when.m4a', 'bella-will.m4a',
        'bella-job.m4a', 'bella-going.m4a', 'bella-baby.m4a',
        'bella-have.m4a', 'bella-lately.m4a', 'bella-salary.m4a',
        'bella-howmuch.m4a', 'bella-class.m4a', 'bella-rank.m4a',

        // Serena
        'serena-marriage.m4a', 'serena-when.m4a', 'serena-will.m4a',
        'serena-job.m4a', 'serena-going.m4a', 'serena-baby.m4a',
        'serena-have.m4a', 'serena-lately.m4a', 'serena-salary.m4a',
        'serena-howmuch.m4a', 'serena-class.m4a', 'serena-rank.m4a',

        // Gia
        'gia-marriage.m4a', 'gia-when.m4a', 'gia-will.m4a',
        'gia-job.m4a', 'gia-going.m4a', 'gia-baby.m4a',
        'gia-have.m4a', 'gia-lately.m4a', 'gia-salary.m4a',
        'gia-howmuch.m4a', 'gia-class.m4a', 'gia-rank.m4a',

        // Seulgi
        'seulgi-marriage.mp3', 'seulgi-when.mp3', 'seulgi-will.mp3',
        'seulgi-job.mp3', 'seulgi-going.mp3', 'seulgi-baby.mp3',
        'seulgi-have.mp3', 'seulgi-lately.mp3', 'seulgi-salary.mp3',
        'seulgi-howmuch.mp3', 'seulgi-class.mp3', 'seulgi-rank.mp3',

        // Roger
        'roger-marriage.mp3', 'roger-when.mp3', 'roger-will.mp3',
        'roger-job.mp3', 'roger-going.mp3', 'roger-baby.mp3',
        'roger-lately.mp3', 'roger-salary.mp3', 'roger-howmuch.mp3',
        'roger-class.mp3', 'roger-rank.mp3'
    ];

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (words.length > 0) drawWords();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // üî• Ï¥àÍ∏∞Ìôî Ìï®Ïàò
    async function init() {
        for (let filename of audioFiles) {
            try {
                const safeName = encodeURIComponent(filename);
                const audio = new Audio(`audio/${safeName}`);

                await new Promise(resolve => {
                    audio.addEventListener("canplaythrough", resolve);
                    audio.addEventListener("error", () => {
                        console.error("Failed:", filename);
                        resolve();
                    });
                    audio.load();
                });

                // ÏòÅÏñ¥ ÌååÏùºÎ™ÖÏóêÏÑú Îã®Ïñ¥ Ï∂îÏ∂ú
                let word = filename
                    .replace(/\.(m4a|mp3)$/i, "")
                    .split("-")
                    .pop(); // ex: richard-marriage ‚Üí "marriage"

                audioElements.push({ audio, word });

            } catch (err) {
                console.error("Load error:", filename, err);
            }
        }

        console.log("Loaded:", audioElements.length);

        createWordLayout();
        animate();

        document.getElementById('loading').style.display = 'none';

        if (audioElements.length > 0) playSequence();
    }

    // Îã®Ïñ¥ Î∞∞Ïπò
    function createWordLayout() {
        words = [];
        const padding = 15;
        const fontSize = 24;

        let x = padding, y = padding, rowHeight = 0;

        let guaranteedWords = [];
        baseWords.forEach(word => {
            for (let i = 0; i < 5; i++) guaranteedWords.push(word);
        });
        guaranteedWords.sort(() => Math.random() - 0.5);

        let index = 0;
        while (y < canvas.height + 100) {
            const word = index < guaranteedWords.length
                ? guaranteedWords[index]
                : baseWords[Math.floor(Math.random() * baseWords.length)];

            const color = colors[Math.floor(Math.random() * colors.length)];

            ctx.font = `500 ${fontSize}px 'Noto Sans KR'`;
            const metrics = ctx.measureText(word);
            const width = metrics.width + padding * 2;
            const height = fontSize + padding * 2;

            if (x + width > canvas.width - padding) {
                x = padding;
                y += rowHeight + 8;
                rowHeight = 0;
            }

            words.push({
                text: word,
                x, y, width, height,
                fontSize, color,
                active: false,
                flickerTime: Math.random() * 1000,
                flickerSpeed: 0.5 + Math.random(),
                slideOffset: 0,
                slideSpeed: 0.4 + Math.random() * 0.8,
                slideDirection: Math.random() > 0.5 ? 1 : -1,
                slideDelay: Math.random() * 10000,
                hasBoxDisappear: true,
                boxDisappearTime: Math.random() * 5000,
                boxVisible: true,
                textColorWhenNoBox: colors[Math.floor(Math.random() * colors.length)],
                hasCompleteDisappear: true,
                disappearTime: Math.random() * 8000,
                disappearDelay: Math.random() * 5000,
                isVisible: true,
                colorChangeCounter: 0
            });

            x += width + 8;
            rowHeight = Math.max(rowHeight, height);
            index++;
        }
    }

    // Ïï†ÎãàÎ©îÏù¥ÏÖò
    function animate() {
        drawWords();
        animationFrame = requestAnimationFrame(animate);
    }

    function drawWords() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const time = Date.now();

        words.forEach(word => {
            if (word.hasCompleteDisappear && !word.active) {
                const cycle = (time + word.disappearDelay) % 5000;
                word.isVisible = cycle > 1200;
            }
            if (!word.isVisible) return;

            if (word.hasBoxDisappear && !word.active) {
                const cycle = (time + word.boxDisappearTime) % 4000;
                word.boxVisible = cycle > 1000;

                if (!word.boxVisible) {
                    word.textColorWhenNoBox = colors[Math.floor(Math.random() * colors.length)];
                }
            }

            if (!word.active) {
                const cycle = (time + word.slideDelay) % 10000;
                if (cycle < 3000) {
                    word.slideOffset += word.slideSpeed * word.slideDirection;
                    if (word.slideOffset > 25 || word.slideOffset < -25) {
                        word.slideDirection *= -1;
                    }
                } else {
                    word.slideOffset *= 0.9;
                }
            }

            ctx.save();

            const flicker = Math.sin((time + word.flickerTime) * word.flickerSpeed * 0.01);
            const opacity = word.active ? 1.0 : 0.25 + flicker * 0.15;

            if (word.boxVisible || word.active) {
                ctx.shadowColor = word.active ? "#ff0000" : word.color;
                ctx.shadowBlur = word.active ? 35 : 8;
                ctx.fillStyle = word.active
                    ? "#ff0000"
                    : adjustAlpha(word.color, opacity);

                ctx.fillRect(word.x, word.y, word.width, word.height);
            }

            ctx.shadowBlur = 0;

            ctx.font = `${word.active ? 700 : 500} ${word.fontSize}px 'Noto Sans KR'`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            ctx.fillStyle = word.active
                ? "#ffffff"
                : word.boxVisible
                    ? "rgba(255,255,255,0.85)"
                    : word.textColorWhenNoBox;

            const tx = word.x + word.width / 2 + word.slideOffset;
            const ty = word.y + word.height / 2;

            ctx.fillText(word.text, tx, ty);
            ctx.restore();
        });
    }

    function adjustAlpha(color, alpha) {
        const r = parseInt(color.slice(1, 3), 16);
        const g = parseInt(color.slice(3, 5), 16);
        const b = parseInt(color.slice(5, 7), 16);
        return `rgba(${r},${g},${b},${alpha})`;
    }

    // üî• ÏûêÎèô Ïû¨ÏÉù Í∏∞Îä•
    function playSequence() {
        if (currentIndex >= audioElements.length) currentIndex = 0;

        const current = audioElements[currentIndex];

        // ÏòÅÏñ¥ wordÍ∞Ä "marriage", "when" Îì±
        words.forEach(w => {
            w.active = (w.text.includes(current.word) || current.word.includes(w.text.replace(/\?/g, "")));
        });

        current.audio.currentTime = 0;
        current.audio.play().catch(err => console.error("Ïû¨ÏÉù Ïã§Ìå®:", err));

        current.audio.onended = () => {
            currentIndex++;
            playSequence();
        };
    }

    init();
</script>
</body>
</html>
